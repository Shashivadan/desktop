'use strict';

var utils = require('../../utils.js');
var promiseTimer = require('./promiseTimer.js');

/**
 * Derives a new {@link AsyncGenerator} based of {@link iterable}, that automatically stops with the
 * passed {@link cancel} promise.
 */ async function* withCancel(iterable, cancel) {
    const cancelPromise = cancel.then(utils.noop);
    const iterator = iterable[Symbol.asyncIterator]();
    while(true){
        const result = await Promise.race([
            iterator.next(),
            cancelPromise
        ]);
        if (result == null) {
            await iterator.return?.();
            break;
        }
        if (result.done) {
            break;
        }
        yield result.value;
    }
}
/**
 * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first
 * {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further
 * values may still come through. After this period, the generator stops.
 */ async function* takeWithGrace(iterable, { count , gracePeriodMs  }) {
    const iterator = iterable[Symbol.asyncIterator]();
    const timer = promiseTimer.createPromiseTimer(gracePeriodMs);
    try {
        while(true){
            const result = await Promise.race([
                iterator.next(),
                timer.promise
            ]);
            if (result == null) {
                // cancelled
                await iterator.return?.();
                break;
            }
            if (result.done) {
                break;
            }
            yield result.value;
            if (--count === 0) {
                timer.start();
            }
        }
    } finally{
        timer.clear();
    }
}

exports.takeWithGrace = takeWithGrace;
exports.withCancel = withCancel;
