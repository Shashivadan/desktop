import { observable } from '@trpc/server/observable';
import { sseStreamConsumer, run } from '@trpc/server/unstable-core-do-not-import';
import { raceAbortSignals } from '../internals/signals.mjs';
import { TRPCClientError } from '../TRPCClientError.mjs';
import { getTransformer } from '../internals/transformer.mjs';
import { getUrl } from './internals/httpUtils.mjs';
import { resultOf } from './internals/urlWithConnectionParams.mjs';

async function urlWithConnectionParams(opts) {
    let url = await resultOf(opts.url);
    if (opts.connectionParams) {
        const params = await resultOf(opts.connectionParams);
        const prefix = url.includes('?') ? '&' : '?';
        url += prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));
    }
    return url;
}
/**
 * @see https://trpc.io/docs/client/links/httpSubscriptionLink
 */ function unstable_httpSubscriptionLink(opts) {
    const transformer = getTransformer(opts.transformer);
    return ()=>{
        return ({ op  })=>{
            return observable((observer)=>{
                const { type , path , input  } = op;
                /* istanbul ignore if -- @preserve */ if (type !== 'subscription') {
                    throw new Error('httpSubscriptionLink only supports subscriptions');
                }
                const ac = new AbortController();
                const signal = raceAbortSignals(op.signal, ac.signal);
                const eventSourceStream = sseStreamConsumer({
                    url: async ()=>getUrl({
                            transformer,
                            url: await urlWithConnectionParams(opts),
                            input,
                            path,
                            type,
                            signal: null
                        }),
                    init: ()=>resultOf(opts.eventSourceOptions),
                    signal,
                    deserialize: transformer.output.deserialize,
                    shouldRecreateOnError: opts.experimental_shouldRecreateOnError
                });
                run(async ()=>{
                    for await (const chunk of eventSourceStream){
                        switch(chunk.type){
                            case 'data':
                                const chunkData = chunk.data;
                                // if the `tracked()`-helper is used, we always have an `id` field
                                const data = 'id' in chunkData ? chunkData : chunkData.data;
                                observer.next({
                                    result: {
                                        data
                                    },
                                    context: {
                                        eventSource: chunk.eventSource
                                    }
                                });
                                break;
                            case 'opened':
                                {
                                    observer.next({
                                        result: {
                                            type: 'started'
                                        },
                                        context: {
                                            eventSource: chunk.eventSource
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    observer.next({
                        result: {
                            type: 'stopped'
                        }
                    });
                    observer.complete();
                }).catch((error)=>{
                    observer.error(TRPCClientError.from(error));
                });
                return ()=>{
                    observer.complete();
                    ac.abort();
                };
            });
        };
    };
}

export { unstable_httpSubscriptionLink };
