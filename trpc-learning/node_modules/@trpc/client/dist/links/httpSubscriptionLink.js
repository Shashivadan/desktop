'use strict';

var observable = require('@trpc/server/observable');
var unstableCoreDoNotImport = require('@trpc/server/unstable-core-do-not-import');
var signals = require('../internals/signals.js');
var TRPCClientError = require('../TRPCClientError.js');
var transformer = require('../internals/transformer.js');
var httpUtils = require('./internals/httpUtils.js');
var urlWithConnectionParams$1 = require('./internals/urlWithConnectionParams.js');

async function urlWithConnectionParams(opts) {
    let url = await urlWithConnectionParams$1.resultOf(opts.url);
    if (opts.connectionParams) {
        const params = await urlWithConnectionParams$1.resultOf(opts.connectionParams);
        const prefix = url.includes('?') ? '&' : '?';
        url += prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));
    }
    return url;
}
/**
 * @see https://trpc.io/docs/client/links/httpSubscriptionLink
 */ function unstable_httpSubscriptionLink(opts) {
    const transformer$1 = transformer.getTransformer(opts.transformer);
    return ()=>{
        return ({ op  })=>{
            return observable.observable((observer)=>{
                const { type , path , input  } = op;
                /* istanbul ignore if -- @preserve */ if (type !== 'subscription') {
                    throw new Error('httpSubscriptionLink only supports subscriptions');
                }
                const ac = new AbortController();
                const signal = signals.raceAbortSignals(op.signal, ac.signal);
                const eventSourceStream = unstableCoreDoNotImport.sseStreamConsumer({
                    url: async ()=>httpUtils.getUrl({
                            transformer: transformer$1,
                            url: await urlWithConnectionParams(opts),
                            input,
                            path,
                            type,
                            signal: null
                        }),
                    init: ()=>urlWithConnectionParams$1.resultOf(opts.eventSourceOptions),
                    signal,
                    deserialize: transformer$1.output.deserialize,
                    shouldRecreateOnError: opts.experimental_shouldRecreateOnError
                });
                unstableCoreDoNotImport.run(async ()=>{
                    for await (const chunk of eventSourceStream){
                        switch(chunk.type){
                            case 'data':
                                const chunkData = chunk.data;
                                // if the `tracked()`-helper is used, we always have an `id` field
                                const data = 'id' in chunkData ? chunkData : chunkData.data;
                                observer.next({
                                    result: {
                                        data
                                    },
                                    context: {
                                        eventSource: chunk.eventSource
                                    }
                                });
                                break;
                            case 'opened':
                                {
                                    observer.next({
                                        result: {
                                            type: 'started'
                                        },
                                        context: {
                                            eventSource: chunk.eventSource
                                        }
                                    });
                                    break;
                                }
                        }
                    }
                    observer.next({
                        result: {
                            type: 'stopped'
                        }
                    });
                    observer.complete();
                }).catch((error)=>{
                    observer.error(TRPCClientError.TRPCClientError.from(error));
                });
                return ()=>{
                    observer.complete();
                    ac.abort();
                };
            });
        };
    };
}

exports.unstable_httpSubscriptionLink = unstable_httpSubscriptionLink;
